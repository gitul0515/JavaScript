연습문제 6번
1-1. 순환식 작성
L[i, j]: 행렬 m의 원소 (1, 1)에서 (i, j)로 이동하는 
         모든 경로의 점수 중 가장 높은 점수

L[i, j]:
  m[i][j] -------------- if i = 1 && j = 1
  // 첫 번째 원소이므로 자기 점수인 m[i][j]가 곧 최대합이다.
  
  L[i-1][j] + m[i][j] -------------- if j = 1
  // m[i][j]로 진입하는 경로는 m[i-1][j]를 거치는 것만이 유일하다. 
  // 즉 L[i][j]가 최대가 되려면 L[i-1][j]가 최대여야 한다.
  // 이를 구하고 자기 점수인 m[i][j]를 더한다.
  
  L[i][j-1] + m[i][j] -------------- if i = 1
  // m[i][j]로 진입하는 경로는 m[i][j-1]를 거치는 것만이 유일하다. 
  // 즉 L[i][j]가 최대가 되려면 L[i][j-1]가 최대여야 한다.
  // 이를 구하고 자기 점수인 m[i][j]를 더한다.
  
  max(L[i-1][j], L[i][j-1], L[i-1][j-1]) + m[i][j] ----- Otherwise
  // m[i][j]로 진입하는 경로는 세 경로(아래쪽, 오른쪽, 오른쪽 대각선)이다. 
  // 즉 L[i][j]가 최대가 되려면 L[i-1][j], L[i][j-1], L[i-1][j-1] 중 최대인 
  // 경로를 거쳐야 한다. 그리고 자기 점수인 m[i][j]를 더한다.

1-2. 행렬 경로 문제 알고리즘 수정
matrixPath(n) // (n, n)에 이르는 최고 점수
{
  for i <- 0 to n
    c[i, o] <- 0;
  for j <- 1 to n
    c[0, j] <- 0;
  for i <- 1 to n
    for j <- 1 to n
      c[i, j] <- m[i, j] + max(c[i-1, j], c[i, j-1], c[i-1, j-1]); // 수정한 부분
  return c[n, n];
}